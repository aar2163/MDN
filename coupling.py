import numpy as np
import sys
import re
import math
import mdn
from sets import Set

"""
 Called by analysis.php
 Usage: python coupling.py ticket effic
"""

def add_output(fname,output_files):
 if(fname not in output_files):
  output_files.append(fname)

def get_effic(a,b,idx1,idx2):
 a = a[np.ix_(idx1,idx2)]
 b = b[np.ix_(idx1,idx2)]
 a = a.flatten()
 b = b.flatten()
 a = a[a != -1]
 b = b[b != -1]
 return np.sum(a)/np.sum(b)

def get_nodeset(data):
 names = data['network']['nodes']['names']
 s = []
 for i in names:
  s.append(Set(mdn.dic2list(data['network']['nodes'][i]['atoms'])))
 return s

def get_nodes(atoms,nodeset):
 s = Set(atoms)
 n = []
 for ii,i in enumerate(nodeset):
  if i.issubset(s):
   n.append(ii)
 return n

def get_effic_array(effic_fn):
 """ 
  each line of effic_fn lists
  actual and ideal network efficiency values
  generated by looping over ii (outer) and jj (inner)
  matrix indices
 """ 
 a = []
 b = []
 
 
 with open(effic_fn,'r') as f:
  for line in f:
   l = re.split(r'\s',line.strip())
   a.append(float(l[0]))
   b.append(float(l[1]))

 return a, b

def get_nodelist(data, valid, nodeset):

 nodelist = []
 for i in valid:
  atoms = mdn.dic2list(data['index']['groups'][str(i)]['atoms'])
  j = get_nodes(atoms,nodeset)
  nodelist.append(j)
 return nodelist



def main():

 ticket   = sys.argv[1]
 effic_fn = sys.argv[2]

 data = mdn.get_data(ticket)
 
 
 """ 
  Get valid groups
 """ 
 valid = mdn.valid_groups_for_analysis(data, False)
 
 
 nodeset = get_nodeset(data)
 
 
 nodelist = get_nodelist(data, valid, nodeset)
 
 
 a, b = get_effic_array(effic_fn)
 
 
 nnodes = int(math.sqrt(len(a)))
 
 
 
 effic = np.zeros((nnodes,nnodes))
 efficid = np.zeros((nnodes,nnodes))

 """ 
  Convert from 1D array to numpy matrix
 """ 
 
 for i in range(len(a)):
   rest = (i % nnodes)
   n = int(float(i)/nnodes)

   if(rest >= n):
    effic[n][rest]   = a[i]
    efficid[n][rest] = b[i]
    effic[rest][n]   = a[i]
    efficid[rest][n] = b[i]
 
 try:
  fname = data['base_dir'] + data['coupling_log']
 except:
  # for old database entries
  fname = data['base_dir'] + data['ticket'] + '-coupling.log'
 
 
 """ 
  Add coupling.log to output list
 """ 
 add_output(fname,data['output_files'])
 
 with open(fname,'w') as f:
  """ 
   Loop over pairs of valid groups and 
   calculate coupling
  """ 
  for ii,i in enumerate(valid):
   iname = data['index']['groups']['names'][i]

   for jj,j in enumerate(valid):
    if(j >= i):
     jname = data['index']['groups']['names'][j]
     f.write("{} - {}: {}\n".format(iname,jname,get_effic(effic,efficid,nodelist[ii],nodelist[jj])))

   f.write("\n")
 
 atoms = []
 
 
 
 globatoms = mdn.do_globatoms(data['topology'])

 """ 
  Loop over pairs of valid groups
  and write the atomic coupling.csv files
 """ 
 
 for ii,i in enumerate(valid):
  iname = data['index']['groups']['names'][i]
  fname = data['base_dir'] + data['ticket'] + '-coupling-' + iname + '.csv'
 
  for hh,h in enumerate(valid):
   if h == i:
    continue

   hname = data['index']['groups']['names'][h]
   fname = data['base_dir'] + data['ticket'] + '-coupling-' + iname + '-' + hname + '.csv'
   add_output(fname,data['output_files'])
 
   with open(fname,'w') as f:
    bLast = False
    f.write("Atom Number,Residue Size,Coupling\n")

    """ 
     Loop over all atoms of group h
    """ 
    for j in mdn.dic2list(data['index']['groups'][str(h)]['atoms']):
     d1 = globatoms[str(j)]
 
     try:
      d2 = globatoms[str(j+1)]
     except:
      bLast = True
    
     atoms.append(j)

     """ 
      Check if this is the last atom of the residue (j),
      in which case we calculate the coupling between residue j
      and group i, and write the whole thing
     """ 
 
     if not mdn.same_residue(d1,d2) or bLast == True:
      node = get_nodes(atoms,nodeset)
      value = get_effic(effic,efficid,node,nodelist[ii])
      for k in atoms:
       f.write("{},{},{}\n".format(k,len(atoms),value))
      atoms = []
 
 
 mdn.update_data(sys.argv[1],data)

if __name__ == '__main__':
 main()
  
